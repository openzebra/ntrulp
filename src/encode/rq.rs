use crate::math::nums::{u32_divmod_u14, u32_mod_u14};

fn encode(out: &mut Vec<u8>, r: &[u16], m: &[u16], len: usize) {
    if len == 1 {
        let mut r_val = r[0];
        let mut m_val = m[0];
        while m_val > 1 {
            out.push(r_val as u8);
            r_val >>= 8;
            m_val = (m_val + 255) >> 8;
        }
    }

    if len > 1 {
        let mut r2 = vec![0; (len + 1) / 2];
        let mut m2 = vec![0; (len + 1) / 2];
        let mut i = 0;
        while i < len - 1 {
            let m0 = m[i] as u32;
            let mut r_val = r[i] as u32 + (r[i + 1] as u32) * m0;
            let mut m_val = (m[i + 1] as u32) * m0;
            while m_val >= 16384 {
                out.push(r_val as u8);
                r_val >>= 8;
                m_val = (m_val + 255) >> 8;
            }
            r2[i / 2] = r_val as u16;
            m2[i / 2] = m_val as u16;
            i += 2;
        }
        if i < len {
            r2[i / 2] = r[i];
            m2[i / 2] = m[i];
        }
        encode(out, &r2, &m2, (len + 1) / 2);
    }
}

fn decode(out: &mut [u16], slice: &[u8], m: &[u16], len: usize) {
    let mut s = slice;

    if len == 1 {
        if m[0] == 1 {
            out[0] = 0;
        } else if m[0] <= 256 {
            out[0] = u32_mod_u14(s[0] as u32, m[0]);
        } else {
            out[0] = u32_mod_u14((s[0] as u32) + (((s[1] as u16) << 8) as u32), m[0]);
        }
    }
    if len > 1 {
        let mut r2 = vec![0u16; (len + 1) / 2];
        let mut m2 = vec![0u16; (len + 1) / 2];
        let mut bottomr = vec![0u16; len / 2];
        let mut bottomt = vec![0u32; len / 2];
        let mut i = 0;
        while i < len - 1 {
            let m_val = (m[i] as u32) * (m[i + 1] as u32);
            if m_val > 256 * 16383 {
                bottomt[i / 2] = 256 * 256;
                bottomr[i / 2] = (s[0] as u16) + 256 * (s[1] as u16);
                s = &s[2..];
                m2[i / 2] = ((((m_val + 255) >> 8) + 255) >> 8) as u16;
            } else if m_val >= 16384 {
                bottomt[i / 2] = 256;
                bottomr[i / 2] = s[0] as u16;
                s = &s[1..];
                m2[i / 2] = ((m_val + 255) >> 8) as u16;
            } else {
                bottomt[i / 2] = 1;
                bottomr[i / 2] = 0;
                m2[i / 2] = m_val as u16;
            }

            i += 2;
        }
        if i < len {
            m2[i / 2] = m[i];
        }
        decode(&mut r2, &s, &m2, (len + 1) / 2);
        i = 0;
        while i < len - 1 {
            let r = bottomr[i / 2] as u32 + bottomt[i / 2] * r2[i / 2] as u32;
            let (mut r1, r0) = u32_divmod_u14(r, m[i]);

            r1 = u32_mod_u14(r1, m[i + 1]) as u32;
            out[i] = r0;
            out[i + 1] = r1 as u16;
            i += 2;
        }
        if i < len {
            out[i] = r2[i / 2];
        }
    }
}

pub fn rq_encode<const P: usize, const Q: usize, const Q12: usize>(rq: &[i16; P]) -> Vec<u8> {
    let mut out = Vec::new();
    let mut r = [0u16; P];
    let m = [Q as u16; P];

    for i in 0..P {
        r[i] = (rq[i] + Q12 as i16) as u16;
    }

    encode(&mut out, &r, &m, P);

    out
}

/// TODO: Add const because s=1158 elements!.
pub fn rq_decode<const P: usize, const Q: usize, const Q12: usize>(s: &[u8]) -> [i16; P] {
    let mut rq = [0i16; P];
    let mut r = [0u16; P];
    let m = [Q as u16; P];

    decode(&mut r, &s, &m, P);

    for i in 0..P {
        rq[i] = (r[i] as i16) - Q12 as i16;
    }

    rq
}

/// TODO: Add const because s=1158 elements!.
pub fn rq_rounded_decode<const P: usize, const Q: usize, const Q12: usize>(s: &[u8]) -> [i16; P] {
    let mut rq = [0i16; P];
    let mut r = [0u16; P];
    let m = [(Q as u16 + 2) / 3; P];

    decode(&mut r, s, &m, P);

    for i in 0..P {
        rq[i] = (r[i] as i16 * 3) - Q12 as i16;
    }

    rq
}

pub fn rq_rounded_encode<const P: usize, const Q: usize, const Q12: usize>(rq: &[i16]) -> Vec<u8> {
    // TODO: know the size!!!!.
    let mut s = Vec::new();
    let mut r = [0u16; P];
    let mut m = [0u16; P];

    for i in 0..P {
        let v32 = (rq[i] + Q12 as i16) as u32;
        r[i] = ((v32 * 10923) >> 15) as u16;
    }

    for i in 0..P {
        m[i] = (Q as u16 + 2) / 3;
    }

    encode(&mut s, &r, &m, P);

    s
}

#[test]
fn test_encode() {
    use crate::kem::rq::Rq;
    use crate::random::CommonRandom;
    use crate::random::NTRURandom;

    const P: usize = 761;
    const W: usize = 286;
    const Q: usize = 4591;
    const Q12: usize = (Q - 1) / 2;

    let mut random: NTRURandom<P> = NTRURandom::new();
    let rq: Rq<P, Q, Q12> = Rq::from(random.short_random(W).unwrap()).recip3().unwrap();
    let out = rq_encode::<P, Q, Q12>(&rq.coeffs);
    let dec = rq_decode::<P, Q, Q12>(&out);

    assert_eq!(dec, rq.coeffs);
}

#[test]
fn test_rounded_encode_decode_random() {
    use crate::kem::rq::Rq;
    use crate::random::CommonRandom;
    use crate::random::NTRURandom;

    const P: usize = 761;
    const W: usize = 286;
    const Q: usize = 4591;
    const Q12: usize = (Q - 1) / 2;

    let mut random: NTRURandom<P> = NTRURandom::new();
    let rq: Rq<P, Q, Q12> = Rq::from(random.short_random(W).unwrap()).recip3().unwrap();
    let out = rq_rounded_encode::<P, Q, Q12>(&rq.coeffs);
    let dec = rq_rounded_decode::<P, Q, Q12>(&out);

    assert_eq!(dec, rq.coeffs);
}

#[test]
fn test_decode_ck() {
    const P: usize = 761;
    const Q: usize = 4591;
    const Q12: usize = (Q - 1) / 2;

    let r: [i16; P] = [
        -520, 218, -2085, -1427, 1138, -1220, 1235, 225, 569, 450, -308, -695, 2235, 1600, 647,
        1366, 1597, -710, 2217, 1482, 1324, -962, 1028, 2158, -113, -494, -1160, 1413, 358, -783,
        -81, 153, 1099, -998, -182, -2031, 1867, -1376, 646, -1601, 1384, 889, 2110, 1829, 1049,
        -584, -2109, -311, -2116, 1328, 807, -1459, -153, -1078, -237, -246, 1352, 1158, 606,
        -1211, -1780, 1501, -480, -75, -206, -93, -944, -214, -391, -315, 2012, 453, 143, 240,
        -280, 175, -925, 2125, 557, 382, -1222, 2238, 2160, 1241, 1020, -1610, -589, -602, 1086,
        -2138, -694, -1215, 1718, -1606, -91, 847, 2035, -1443, 376, 536, 944, -31, 2051, -1469,
        -2294, -2034, 919, 1010, 535, -1166, -2006, -2017, 1602, -115, 1854, -1029, -2242, -1884,
        -761, 1890, -2038, 1463, 233, 757, 846, 1086, -2097, -582, -1367, 852, -1395, 1172, 815,
        -696, 755, -1802, -844, -601, 1791, 750, 742, -2026, 1640, -1200, 962, 1853, 2206, 1073,
        1588, 737, 1887, 126, 1802, -1575, 1328, 1820, -952, -480, -2289, 1873, 1229, -371, 748,
        2239, -1706, -714, 1979, -806, 1949, 1940, 33, -35, -970, -150, 28, 2156, 1786, -519, -307,
        -242, -825, -265, -1972, -218, -2101, -1882, -1333, 1861, -915, -100, -992, -1353, 1949,
        -1683, -2153, -105, 1004, -975, -1839, -415, 1967, 1041, 1041, 77, 924, -544, -431, 721,
        -963, 2142, -1566, 453, 735, -2149, 624, -1968, 363, -436, -238, 996, -1459, 786, 1265,
        2202, -1417, -685, 797, -1727, 1383, -2119, 728, -137, -675, 1265, 1829, 1842, 179, 448,
        -341, -708, -1731, 2239, -1878, -1062, 2017, 2214, 243, 127, 2197, -1213, -921, 1941, -958,
        -2165, -1881, 473, 9, 1307, 844, -1804, 1205, -690, -1287, 1086, -1489, -1094, 1706, -1045,
        823, 1197, -658, -492, 320, 460, 42, -443, -613, -786, -1136, 185, 788, -884, 476, -1798,
        -330, -173, -695, -2050, 1990, -1813, 1068, -745, -186, 627, -1798, 1038, 313, -1688, 2004,
        -1412, 1411, -1658, 847, 1177, -1302, -1711, -544, 1255, 334, 1496, 1762, -719, 867, -637,
        -713, 2025, 1654, -641, -343, -1023, 144, -2138, 649, -386, -86, -1096, 1690, -1875, -417,
        -1720, 412, 618, -910, 422, 766, 1719, -709, 436, -1305, 731, -1918, 1132, 1937, -46, -158,
        896, -1927, 272, 1011, 1349, 353, -1076, 796, -1839, -981, -699, 1624, 2096, -1811, 1645,
        -242, 1939, 165, 783, 1008, 820, -1643, 971, 533, 995, 1673, -1862, -1802, -1702, 1611,
        -969, -1025, -1199, 45, -2191, -478, -1754, -1434, 370, -1868, -744, -1378, -1797, -2244,
        1067, 569, -1400, -1883, -985, -1175, 1285, -1956, -2026, 1415, 1608, 57, -718, -1754,
        1578, 1844, 2224, 1177, 911, -2269, 148, 1023, 517, 2180, 492, 998, -1670, -34, -1859,
        -1535, 1985, 48, -582, 823, -183, -1419, -910, 294, 148, 1391, -988, 109, -798, 1492, 2260,
        288, -1004, 1530, 422, 1974, -1677, 384, 1976, -2269, -1284, -666, -1917, -1208, -1950,
        -180, -75, -1589, -1026, -2129, -24, -973, -1204, 1440, -157, -1184, -650, -1188, -1089,
        -1037, 1848, -1217, 2190, 538, -2154, -785, -1287, -1886, -1494, -2180, 203, -103, 1023,
        -1039, -909, -889, 1605, -467, 1290, -282, -2137, 2289, 1515, 1855, 672, -1148, 321, -1249,
        1480, -97, 2290, 681, 1061, 1093, -1558, -1769, 1783, -108, 2145, -1212, -1696, -1208,
        -2116, 1339, 484, 95, 2057, 600, -485, 1248, -2053, 1502, 1184, -690, -2188, 1499, -308,
        224, -1673, 708, -412, -882, 1940, -1134, 742, 811, 208, -66, -1972, 844, 1461, -551, 1804,
        1302, -1417, 1710, -1693, -1292, 1002, -1841, 358, -75, 75, -1659, 1694, 997, 1657, -2040,
        1262, 635, 1480, 2056, -1610, 1034, 1925, -1051, -1966, 1214, 2078, 1209, -561, 1579, 26,
        87, 612, 1130, -2244, 2268, -931, 423, -1775, -826, -886, 1045, -2196, 1233, -750, 513,
        -1858, 549, 910, -1691, 975, 1011, -826, 2231, -341, -969, -367, -408, -1083, 831, 66,
        1637, -430, 2097, -1306, 1122, 1905, 1156, -2032, 680, -395, 1191, -97, 697, 287, 1292,
        540, 633, -544, 160, 466, -704, -505, -2085, -2076, -93, 1517, 1350, 691, 1081, -410, 628,
        536, -1712, -844, -934, -2125, 2195, 1088, 994, 1311, -1791, -1608, 1830, 181, 1037, 741,
        1017, -1379, 2195, -1209, 2037, 1810, 824, -940, 1322, -2114, 1211, 250, 1805, 50, 1856,
        234, 553, 1280, -1562, -1875, 956, -595, 1122, 1604, 475, -1667, -1842, -2219, 1051, 1446,
        375, -213, -656, -311, -956, -175, 743, -1957, 1643, -912, -1261, 277, 1670, -1338, -575,
        -718, 665, -1571, 1360, 1805, 1514, -2147, -2103, -2294, -1974, -1315, 1233, -1914, 1281,
        -976, 1721, -2203, -419, -1469, 757, -532, 1883, -218, 1446, 2120, -1564, -646, -2260,
        2059, -2222, 2036, -1920, 1232, -1920, -2269, 1619, 1687, 1682, 851, 841, -1907, 1345,
        1955, -679, 1023, -513, -670, -48, 212, 990, 1813, 903, 2198, -1667, -1639, 1928, 520, 78,
        -1321, -2273, 2111, -831, -1382, 2043, 474, 143, 415, 856, 336, 952, 1860, -628, -621,
        -1404,
    ];

    let dec = rq_rounded_encode::<P, Q, Q12>(&r);
    let enc = rq_rounded_decode::<P, Q, Q12>(&dec);

    for c in enc {
        print!("{c}, ");
    }
}
